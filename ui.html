  <!-- GR1D is a costume p5.js project created by Ynwu prompting Opus4 -->
  <!-- free of use, edit, do whatever tf u want with it -->
  <!-- enjoy! -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GR1D</title>

  <!-- =============================================== -->
  <!-- EXTERNAL LIBRARIES -->
  <!-- =============================================== -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://unpkg.com/p5.js-svg@1.0.1/lib/p5.svg.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  
  <style>
    /* =============================================== */
    /* BASE STYLES */
    /* =============================================== */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      font-family: "JetBrains Mono", monospace;
      background: #ebebeb;
      color: #646464;
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      z-index: 1;
      background: white;
    }

    /* =============================================== */
    /* CONTROL PANEL LAYOUT */
    /* =============================================== */
    #control-panel {
      display: flex;
      flex-direction: column;
      position: absolute;
      top: 0;
      right: 0;
      width: 240px;
      height: 100%;
      background: #ebebeb;
      padding: 20px 15px 20px 15px;
      box-sizing: border-box;
      z-index: 10;
      overflow-y: auto;
    }

    .section {
      margin-bottom: 40px;
    }

    .section-title {
      font-size: 12px;
      color: #000;
      font-weight: 600;
      margin-bottom: 20px;
      letter-spacing: 0.5px;
    }

    /* =============================================== */
    /* PARAMETER CONTROLS */
    /* =============================================== */
    .param-group {
      margin-bottom: 8px;
    }

    .param-label {
      font-size: 10px;
      color: #646464;
      margin-bottom: 5px;
      display: block;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .param-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .param-value {
      min-width: 32px;
      background: white;
      border: 1px solid #ddd;
      color: #000;
      font-family: "JetBrains Mono", monospace;
      font-size: 10px;
      text-align: center;
      padding: 4px 6px;
      font-weight: 600;
    }

    /* =============================================== */
    /* SLIDER STYLES */
    /* =============================================== */
    input[type="range"] {
      flex: 1;
      appearance: none;
      height: 3px;
      background: #ddd;
      outline: none;
      border-radius: 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      background: #000;
      cursor: pointer;
      border-radius: 0;
    }

    input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #000;
      cursor: pointer;
      border: none;
      border-radius: 0;
    }

    /* =============================================== */
    /* SELECT DROPDOWN STYLES */
    /* =============================================== */
    select {
      width: 100%;
      background: white;
      border: 1px solid #ddd;
      color: #000;
      font-family: "JetBrains Mono", monospace;
      font-size: 10px;
      padding: 6px 8px;
      font-weight: 600;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23646464' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 8px center;
      background-repeat: no-repeat;
      background-size: 16px;
      padding-right: 32px;
    }

    /* =============================================== */
    /* BUTTON STYLES */
    /* =============================================== */
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    button {
      width: 100%;
      padding: 8px 12px;
      border: none;
      background: white;
      color: #646464;
      font-family: "JetBrains Mono", monospace;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
      text-align: left;
    }

    button:hover {
      background: #d0e1ff;
      color: #000;
    }

    button:active {
      background: #aacdfff0;
      color: #000;
    }

    button.active {
      background: #0000ff;
      color: white;
    }

    button.active:hover {
      background: #0000cc;
    }

    /* Button shortcuts display */
    button::after {
      content: attr(data-shortcut);
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 9px;
      opacity: 0.6;
    }

    /* =============================================== */
    /* CHECKBOX STYLES */
    /* =============================================== */
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 15px 0;
      padding: 6px 0;
    }

    input[type="checkbox"] {
      appearance: none;
      width: 12px;
      height: 12px;
      border: 1px solid #ddd;
      background: white;
      position: relative;
      cursor: pointer;
    }

    input[type="checkbox"]:checked {
      background: #000;
      border-color: #000;
    }

    input[type="checkbox"]:checked::after {
      content: '✓';
      position: absolute;
      top: -2px;
      left: 1px;
      color: white;
      font-size: 10px;
      font-weight: bold;
    }

    .checkbox-label {
      font-size: 10px;
      color: #646464;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
    }

    /* =============================================== */
    /* SPECIAL BUTTONS & PRESETS */
    /* =============================================== */
    .special-button {
      background: #000 !important;
      color: white !important;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .special-button:hover {
      background: #333 !important;
    }

    #clear {
      margin-top: 4px;
      margin-bottom: 10px;
    }

    .param-group.preset-group {
      margin-top: 20px;
      margin-bottom: 5px;
    }

    .preset-buttons {
      display: flex;
      gap: 6px;
    }

    .preset-btn {
      flex: 1;
      font-size: 10px;
      padding: 4px 0;
      font-family: "JetBrains Mono", monospace;
      background: white;
      text-align: center;
      color: #646464;
      border: 1px solid #ddd;
      cursor: pointer;
      transition: all 0.05s ease;
    }

    .preset-btn:hover {
      background: #b9b9b9;
      color: #000;
    }

    .preset-btn.active {
      background: #000;
      color: white;
      border-color: #000;
    }

    /* =============================================== */
    /* SHAPE SELECTOR */
    /* =============================================== */
    .shape-buttons {
      display: flex;
      gap: 6px;
      margin-bottom: 15px;
    }

    .shape-btn {
      flex: 1;
      font-size: 10px;
      padding: 8px 0;
      font-family: "JetBrains Mono", monospace;
      background: white;
      text-align: center;
      color: #646464;
      border: 1px solid #ddd;
      cursor: pointer;
      transition: all 0.05s ease;
    }

    .shape-btn:hover {
      background: #d0e1ff;
      color: #000;
    }

    .shape-btn.active {
      background: #0000ff;
      color: white;
      border-color: #0000ff;
    }

    /* =============================================== */
    /* FOOTER CREDIT */
    /* =============================================== */
    .credit {
      font-family: "Inter", sans-serif; 
      margin-top: 20px;
      bottom: 20px;
      left: 0;
      right: 0;
      font-size: 11px;
      color: #888888;
      text-align: right;
      width: 100%;
    }
  </style>
</head>
<body>

  <!-- =============================================== -->
  <!-- CONTROL PANEL HTML -->
  <!-- =============================================== -->
  <div id="control-panel">

    <!-- FUNCTION BUTTONS SECTION -->
    <div class="section">
      <div class="section-title">FUNC</div>
      
      <div class="button-group">
        <button id="undo" data-shortcut="Z">UNDO</button>
        <button id="clear" style="margin-bottom: 10px;" data-shortcut="X">CLEAR</button>
        <button id="toggleWarp" data-shortcut="W">WARP</button>
        <button id="toggleColor" data-shortcut="C">COLOR</button>
        <button id="toggleOutline" data-shortcut="O">OUTLINE</button>
        <button id="toggleGrid" class="active" data-shortcut="G">SHOW GRID</button>
      </div>
    </div>

    <!-- BRUSH SECTION -->
    <div class="section">
      <div class="section-title">BRUSH</div>
      
      <div class="param-group">
        <label class="param-label">Shape</label>
        <div class="shape-buttons">
          <button class="shape-btn active" data-shape="circle">●</button>
          <button class="shape-btn" data-shape="square">■</button>
        </div>
      </div>
      
      <div class="checkbox-row" id="square-connector-row" style="display: none;">
        <input type="checkbox" id="corner-connect" />
        <label class="checkbox-label" for="corner-connect">UNISON LINE WEIGHT</label>
      </div>
    </div>

    <!-- GRID PARAMETERS SECTION -->
    <div class="section">
      <div class="section-title">GRID</div>
      
      <div class="param-group">
        <label class="param-label">Radius</label>
        <div class="param-row">
          <input type="range" id="radius" min="4" max="65" value="24">
          <div class="param-value" id="radius-val">24</div>
        </div>
      </div>

      <div class="param-group">
        <label class="param-label">Spacing</label>
        <div class="param-row">
          <input type="range" id="spacing" min="10" max="150" value="60">
          <div class="param-value" id="spacing-val">60</div>
        </div>
      </div>

      <div class="param-group">
        <label class="param-label">Margin</label>
        <div class="param-row">
          <input type="range" id="margin" min="0" max="200" value="50">
          <div class="param-value" id="margin-val">50</div>
        </div>
      </div>

      <div class="param-group">
        <label class="param-label">Cols</label>
        <div class="param-row">
          <input type="range" id="cols" min="3" max="12" value="6">
          <div class="param-value" id="cols-val">6</div>
        </div>
      </div>

      <div class="param-group">
        <label class="param-label">Rows</label>
        <div class="param-row">
          <input type="range" id="rows" min="3" max="12" value="6">
          <div class="param-value" id="rows-val">6</div>
        </div>
      </div>

      <!-- GRID PRESETS -->
      <div class="param-group preset-group">
        <label class="param-label">PRESET</label>
        <div class="preset-buttons">
          <button class="preset-btn" data-preset="3x3">3</button>
          <button class="preset-btn" data-preset="4x4">4</button>
          <button class="preset-btn" data-preset="5x5">5</button>
          <button class="preset-btn active" data-preset="6x6">6</button>
          <button class="preset-btn" data-preset="10x10">10</button>
        </div>
      </div>
    </div>

    <!-- EXPORT SECTION -->
    <div class="section">
      <div class="section-title">EXPORT</div>
      
      <div class="param-group">
        <label class="param-label">Size</label>
        <select id="export-size">
          <option value="16">16×16</option>
          <option value="24" selected>24×24</option>
          <option value="32">32×32</option>
          <option value="48">48×48</option>
          <option value="64">64×64</option>
        </select>
      </div>

      <div class="checkbox-row">
        <input type="checkbox" id="mode-toggle" />
        <label class="checkbox-label" for="mode-toggle">Export as lines</label>
      </div>

      <div class="button-group">
        <button id="send-to-figma" class="special-button">Paste to Figma</button>
      </div>
    </div>

    <!-- EXPERIMENTAL SECTION -->
    <div class="section">
      <div class="section-title">EXPERIMENTAL</div>
      
      <div class="button-group">
        <button id="surprise" data-shortcut="S">SURPISE ME</button>
        <button id="toggleGameOfLife" data-shortcut="L">GAME OF LIFE</button>
      </div>
      
      <div id="game-of-life-controls" style="display: none; margin-top: 10px;">
        <div class="param-group">
          <label class="param-label">Speed</label>
          <div class="param-row">
            <input type="range" id="gol-speed" min="1" max="30" value="10">
            <div class="param-value" id="gol-speed-val">10</div>
          </div>
        </div>
        
        <div class="button-group" style="margin-top: 10px;">
          <button id="gol-play" style="background: #4CAF50; color: white;">PLAY</button>
          <button id="gol-step">STEP</button>
          <button id="gol-clear">CLEAR CELLS</button>
        </div>
      </div>
    </div>
    
    <!-- FOOTER CREDIT -->
    <div class="credit">৻( •̀ ᗜ •́ ৻) ✧ @ynwumk5</div>
  </div>

  <script>
    // ===============================================
    // GLOBAL VARIABLES
    // ===============================================
    
    // Grid configuration
    let cols = 6;
    let rows = 6;
    let radius = 24;
    let spacing = 60;
    let margin = 50;

    // Drawing data
    let grid = [];
    let strokes = [];
    let strokeColors = [];
    let strokeShapes = []; // New array to store shape for each stroke
    let currentStroke = [];

    // History management
    let undoStack = [];

    // Drawing modes and toggles
    let useColors = false;
    let outlineOnly = false;
    let showGrid = true;
    let warpMode = false;
    let warpStartPoint = null;
    let brushShape = 'circle'; // New variable for brush shape
    let squareConnectorMode = 'corner'; // 'corner' or 'center'
    
    // Game of Life variables
    let gameOfLifeMode = false;
    let gameOfLifeRunning = false;
    let gameOfLifeGrid = [];
    let gameOfLifeSpeed = 10; // frames between updates
    let frameCounter = 0;

    // ===============================================
    // P5.JS SETUP AND DRAW FUNCTIONS
    // ===============================================
    
    function setup() {
      let canvas = createCanvas(window.innerWidth - 240, window.innerHeight);
      canvas.parent(document.body);
      canvas.style("z-index", "1");
      updateValues();
      rebuildGrid();
      setupParamUpdates();
      setupShapeButtons();
    }

    function draw() {
      background(250);

      // Draw grid dots if enabled
      if (showGrid && !gameOfLifeMode) {
        stroke(200);
        strokeWeight(1);
        noFill();
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            // Draw grid shape based on current brush shape
            if (brushShape === 'square') {
              rectMode(CENTER);
              rect(grid[i][j].x, grid[i][j].y, radius * 2, radius * 2);
            } else {
              ellipse(grid[i][j].x, grid[i][j].y, radius * 2);
            }
          }
        }
      }

      // Game of Life mode
      if (gameOfLifeMode) {
        // Draw grid background
        stroke(200);
        strokeWeight(1);
        noFill();
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            rectMode(CENTER);
            rect(grid[i][j].x, grid[i][j].y, radius * 2, radius * 2);
          }
        }
        
        // Draw living cells
        fill(useColors ? color(random(30, 220), random(30, 220), random(30, 220)) : 0);
        noStroke();
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            if (gameOfLifeGrid[i] && gameOfLifeGrid[i][j]) {
              rectMode(CENTER);
              rect(grid[i][j].x, grid[i][j].y, radius * 2, radius * 2);
            }
          }
        }
        
        // Update Game of Life
        if (gameOfLifeRunning) {
          frameCounter++;
          if (frameCounter >= gameOfLifeSpeed) {
            updateGameOfLife();
            frameCounter = 0;
          }
        }
      } else {
        // Normal drawing mode
        // Highlight warp start point
        if (warpMode && warpStartPoint) {
          fill(0, 0, 255, 100);
          noStroke();
          ellipse(warpStartPoint.x, warpStartPoint.y, radius * 2.5);
        }

        // Draw completed strokes
        for (let i = 0; i < strokes.length; i++) {
          drawStroke(strokes[i], useColors ? strokeColors[i] : color(0), strokeShapes[i]);
        }
        
        // Draw current stroke being drawn
        drawStroke(currentStroke, color(100, 100, 100, 150), brushShape);
      }
    }

    // ===============================================
    // DRAWING UTILITIES
    // ===============================================
    
    function drawStroke(strokePath, col, shape) {
      if (strokePath.length === 0) return;
      
      if (outlineOnly) {
        stroke(col);
        strokeWeight(1);
        noFill();
      } else {
        fill(col);
        noStroke();
      }

      // Draw shapes at each point and connectors between them
      for (let i = 0; i < strokePath.length; i++) {
        let p = strokePath[i];
        drawShape(p.x, p.y, radius, shape);
        if (i > 0) {
          if (shape === 'circle') {
            drawCapsule(strokePath[i - 1], strokePath[i], radius);
          } else {
            drawConnector(strokePath[i - 1], strokePath[i], radius, shape);
          }
        }
      }
    }

    function drawShape(x, y, r, shape) {
      push();
      translate(x, y);
      
      switch(shape) {
        case 'square':
          rectMode(CENTER);
          if (outlineOnly) {
            rect(0, 0, r * 2, r * 2);
          } else {
            rect(0, 0, r * 2, r * 2);
          }
          break;
          
        case 'circle':
        default:
          ellipse(0, 0, r * 2);
          break;
      }
      
      pop();
    }

    function drawCapsule(a, b, r) {
      let dir = p5.Vector.sub(b, a).normalize();
      let perp = createVector(-dir.y, dir.x).mult(r);
      let a1 = p5.Vector.add(a, perp);
      let a2 = p5.Vector.sub(a, perp);
      let b1 = p5.Vector.add(b, perp);
      let b2 = p5.Vector.sub(b, perp);
      beginShape();
      vertex(a1.x, a1.y); vertex(b1.x, b1.y);
      vertex(b2.x, b2.y); vertex(a2.x, a2.y);
      endShape(CLOSE);
    }

    function drawConnector(a, b, r, shape) {
      if (shape === 'square' && squareConnectorMode === 'corner') {
        // For squares with corner mode, connect from corners
        let dir = p5.Vector.sub(b, a);
        let angle = atan2(dir.y, dir.x);
        
        // Determine which corners to connect based on direction
        let aCorner1, aCorner2, bCorner1, bCorner2;
        
        // Calculate the 8 possible directions (for grid movement)
        // and choose appropriate corners
        if (abs(dir.x) > abs(dir.y)) {
          // Mostly horizontal movement
          if (dir.x > 0) {
            // Moving right
            aCorner1 = createVector(a.x + r, a.y - r);
            aCorner2 = createVector(a.x + r, a.y + r);
            bCorner1 = createVector(b.x - r, b.y - r);
            bCorner2 = createVector(b.x - r, b.y + r);
          } else {
            // Moving left
            aCorner1 = createVector(a.x - r, a.y - r);
            aCorner2 = createVector(a.x - r, a.y + r);
            bCorner1 = createVector(b.x + r, b.y - r);
            bCorner2 = createVector(b.x + r, b.y + r);
          }
        } else {
          // Mostly vertical movement
          if (dir.y > 0) {
            // Moving down
            aCorner1 = createVector(a.x - r, a.y + r);
            aCorner2 = createVector(a.x + r, a.y + r);
            bCorner1 = createVector(b.x - r, b.y - r);
            bCorner2 = createVector(b.x + r, b.y - r);
          } else {
            // Moving up
            aCorner1 = createVector(a.x - r, a.y - r);
            aCorner2 = createVector(a.x + r, a.y - r);
            bCorner1 = createVector(b.x - r, b.y + r);
            bCorner2 = createVector(b.x + r, b.y + r);
          }
        }
        
        // Handle diagonal movements
        if (abs(dir.x) > 0 && abs(dir.y) > 0 && abs(abs(dir.x) - abs(dir.y)) < 10) {
          // Diagonal movement
          if (dir.x > 0 && dir.y > 0) {
            // Down-right
            aCorner1 = createVector(a.x + r, a.y - r);
            aCorner2 = createVector(a.x - r, a.y + r);
            bCorner1 = createVector(b.x + r, b.y - r);
            bCorner2 = createVector(b.x - r, b.y + r);
          } else if (dir.x > 0 && dir.y < 0) {
            // Up-right
            aCorner1 = createVector(a.x - r, a.y - r);
            aCorner2 = createVector(a.x + r, a.y + r);
            bCorner1 = createVector(b.x - r, b.y - r);
            bCorner2 = createVector(b.x + r, b.y + r);
          } else if (dir.x < 0 && dir.y > 0) {
            // Down-left
            aCorner1 = createVector(a.x + r, a.y + r);
            aCorner2 = createVector(a.x - r, a.y - r);
            bCorner1 = createVector(b.x + r, b.y + r);
            bCorner2 = createVector(b.x - r, b.y - r);
          } else {
            // Up-left
            aCorner1 = createVector(a.x - r, a.y + r);
            aCorner2 = createVector(a.x + r, a.y - r);
            bCorner1 = createVector(b.x - r, b.y + r);
            bCorner2 = createVector(b.x + r, b.y - r);
          }
        }
        
        beginShape();
        vertex(aCorner1.x, aCorner1.y);
        vertex(bCorner1.x, bCorner1.y);
        vertex(bCorner2.x, bCorner2.y);
        vertex(aCorner2.x, aCorner2.y);
        endShape(CLOSE);
        
      } else {
        // For circles and squares with center mode, use the standard capsule connection
        let dir = p5.Vector.sub(b, a).normalize();
        let perp = createVector(-dir.y, dir.x).mult(r);
        
        let a1 = p5.Vector.add(a, perp);
        let a2 = p5.Vector.sub(a, perp);
        let b1 = p5.Vector.add(b, perp);
        let b2 = p5.Vector.sub(b, perp);
        
        beginShape();
        vertex(a1.x, a1.y);
        vertex(b1.x, b1.y);
        vertex(b2.x, b2.y);
        vertex(a2.x, a2.y);
        endShape(CLOSE);
      }
    }

    // ===============================================
    // GRID MANAGEMENT
    // ===============================================
    
    function rebuildGrid() {
      grid = [];
      for (let i = 0; i < cols; i++) {
        grid[i] = [];
        for (let j = 0; j < rows; j++) {
          grid[i][j] = createVector(margin + i * spacing, margin + j * spacing);
        }
      }
    }

    function updateValues() {
      let oldSpacing = spacing;
      let oldMargin = margin;

      // Read values from UI controls
      radius = parseInt(document.getElementById("radius").value);
      spacing = parseInt(document.getElementById("spacing").value);
      margin = parseInt(document.getElementById("margin").value);
      cols = parseInt(document.getElementById("cols").value);
      rows = parseInt(document.getElementById("rows").value);

      // Scale existing strokes to match new grid
      let ds = spacing / oldSpacing;
      for (let stroke of strokes) {
        for (let p of stroke) {
          p.x = (p.x - oldMargin) * ds + margin;
          p.y = (p.y - oldMargin) * ds + margin;
        }
      }
      for (let p of currentStroke) {
        p.x = (p.x - oldMargin) * ds + margin;
        p.y = (p.y - oldMargin) * ds + margin;
      }

      rebuildGrid();
    }

    // ===============================================
    // GAME OF LIFE FUNCTIONS
    // ===============================================
    
    function initGameOfLife() {
      gameOfLifeGrid = [];
      for (let i = 0; i < cols; i++) {
        gameOfLifeGrid[i] = [];
        for (let j = 0; j < rows; j++) {
          gameOfLifeGrid[i][j] = false;
        }
      }
      
      // Convert existing drawing to Game of Life cells
      for (let stroke of strokes) {
        for (let point of stroke) {
          let gridPos = findGridPosition(point);
          if (gridPos) {
            gameOfLifeGrid[gridPos.i][gridPos.j] = true;
          }
        }
      }
    }
    
    function findGridPosition(point) {
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          if (dist(point.x, point.y, grid[i][j].x, grid[i][j].y) < radius) {
            return { i, j };
          }
        }
      }
      return null;
    }
    
    function updateGameOfLife() {
      let newGrid = [];
      
      for (let i = 0; i < cols; i++) {
        newGrid[i] = [];
        for (let j = 0; j < rows; j++) {
          let neighbors = countNeighbors(i, j);
          let currentState = gameOfLifeGrid[i][j];
          
          // Conway's Game of Life rules
          if (currentState && (neighbors === 2 || neighbors === 3)) {
            newGrid[i][j] = true; // Cell survives
          } else if (!currentState && neighbors === 3) {
            newGrid[i][j] = true; // Cell is born
          } else {
            newGrid[i][j] = false; // Cell dies or stays dead
          }
        }
      }
      
      gameOfLifeGrid = newGrid;
    }
    
    function countNeighbors(x, y) {
      let count = 0;
      
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue;
          
          let col = x + i;
          let row = y + j;
          
          // Wrap around edges (toroidal topology)
          if (col < 0) col = cols - 1;
          if (col >= cols) col = 0;
          if (row < 0) row = rows - 1;
          if (row >= rows) row = 0;
          
          if (gameOfLifeGrid[col] && gameOfLifeGrid[col][row]) {
            count++;
          }
        }
      }
      
      return count;
    }

    // ===============================================
    // MOUSE INTERACTION HANDLERS
    // ===============================================
    
    window.mousePressed = function () {
      if (mouseX < window.innerWidth - 240) {
        if (gameOfLifeMode) {
          // Toggle cells in Game of Life mode
          let gridPos = null;
          for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
              if (dist(mouseX, mouseY, grid[i][j].x, grid[i][j].y) < radius) {
                gridPos = { i, j };
                break;
              }
            }
            if (gridPos) break;
          }
          
          if (gridPos) {
            gameOfLifeGrid[gridPos.i][gridPos.j] = !gameOfLifeGrid[gridPos.i][gridPos.j];
          }
        } else if (warpMode) {
          let point = findClosestNode(mouseX, mouseY);
          if (point) {
            if (!warpStartPoint) {
              // First click - set start point
              warpStartPoint = point.copy();
            } else {
              // Second click - create warp stroke
              if (!point.equals(warpStartPoint)) {
                let warpStroke = [warpStartPoint.copy(), point.copy()];
                const col = useColors
                  ? color(random(30, 220), random(30, 220), random(30, 220))
                  : color(0);
                undoStack.push({ stroke: warpStroke, color: col, shape: brushShape });
                applyUndoStack(); 
              }
              warpStartPoint = null;
            }
          }
        } else {
          currentStroke = [];
        }
      }
    };

    window.mouseDragged = function () {
      if (mouseX < window.innerWidth - 240) {
        if (gameOfLifeMode) {
          // Allow painting cells while dragging
          let gridPos = null;
          for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
              if (dist(mouseX, mouseY, grid[i][j].x, grid[i][j].y) < radius) {
                gridPos = { i, j };
                break;
              }
            }
            if (gridPos) break;
          }
          
          if (gridPos) {
            gameOfLifeGrid[gridPos.i][gridPos.j] = true;
          }
        } else if (!warpMode) {
          let point = findClosestNode(mouseX, mouseY);
          if (point && !pointInStroke(point, currentStroke)) {
            currentStroke.push(point.copy());
          }
        }
      }
    };

    window.mouseReleased = function () {
      if (currentStroke.length > 0 && !warpMode) {
        undoStack.push({
          stroke: currentStroke.map(p => p.copy()),
          color: useColors ? color(random(30, 220), random(30, 220), random(30, 220)) : color(0),
          shape: brushShape
        });
        applyUndoStack();
        currentStroke = [];
      }
    };

    // ===============================================
    // UTILITY FUNCTIONS
    // ===============================================
    
    function findClosestNode(x, y) {
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          let node = grid[i][j];
          if (dist(x, y, node.x, node.y) < radius * 1.2) return node.copy();
        }
      }
      return null;
    }

    function pointInStroke(p, stroke) {
      return stroke.some(pt => p.equals(pt));
    }

    function applyUndoStack() {
      strokes = undoStack.map(entry => entry.stroke);
      strokeColors = undoStack.map(entry => entry.color);
      strokeShapes = undoStack.map(entry => entry.shape || 'circle');
    }

    // ===============================================
    // UI PARAMETER SETUP
    // ===============================================
    
    function setupParamUpdates() {
      const params = ['radius', 'spacing', 'margin', 'cols', 'rows'];
      params.forEach(param => {
        const slider = document.getElementById(param);
        const display = document.getElementById(param + '-val');
        
        slider.addEventListener('input', () => {
          display.textContent = slider.value;
          updateValues();
        });
      });
    }

    function setupShapeButtons() {
      document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          brushShape = btn.dataset.shape;
          document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          // Show/hide square connector option
          const squareConnectorRow = document.getElementById('square-connector-row');
          if (brushShape === 'square') {
            squareConnectorRow.style.display = 'flex';
          } else {
            squareConnectorRow.style.display = 'none';
          }
        });
      });
      
      // Setup corner connect toggle
      document.getElementById('corner-connect').addEventListener('change', (e) => {
        squareConnectorMode = e.target.checked ? 'corner' : 'center';
      });
    }

    // ===============================================
    // GRID PRESETS
    // ===============================================
    
    const presetConfigs = {
      "3x3":   { radius: 30, spacing: 140, margin: 60, cols: 3, rows: 3 },
      "4x4":   { radius: 37, spacing: 93,  margin: 65, cols: 4, rows: 4 },
      "5x5":   { radius: 20, spacing: 70,  margin: 60, cols: 5, rows: 5 },
      "6x6":   { radius: 24, spacing: 60,  margin: 50, cols: 6, rows: 6 },
      "10x10": { radius: 17, spacing: 38,  margin: 30, cols: 10, rows: 10 }
    };

    document.querySelectorAll(".preset-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const preset = btn.dataset.preset;
        const config = presetConfigs[preset];
        if (!config) return;

        // Apply preset to UI controls
        document.getElementById("radius").value = config.radius;
        document.getElementById("spacing").value = config.spacing;
        document.getElementById("margin").value = config.margin;
        document.getElementById("cols").value = config.cols;
        document.getElementById("rows").value = config.rows;

        // Update slider value displays
        document.getElementById("radius-val").textContent = config.radius;
        document.getElementById("spacing-val").textContent = config.spacing;
        document.getElementById("margin-val").textContent = config.margin;
        document.getElementById("cols-val").textContent = config.cols;
        document.getElementById("rows-val").textContent = config.rows;

        // Update grid
        updateValues();

        // Toggle active state
        document.querySelectorAll(".preset-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
      });
    });

    // ===============================================
    // BUTTON EVENT LISTENERS
    // ===============================================
    
    // Clear button
    document.getElementById("clear").addEventListener("click", () => {
      strokes = [];
      strokeColors = [];
      strokeShapes = [];
      currentStroke = [];
      undoStack = [];
      warpStartPoint = null;
    });

    // Toggle buttons
    document.getElementById("toggleColor").addEventListener("click", (e) => {
      useColors = !useColors;
      e.target.classList.toggle('active', useColors);
    });

    document.getElementById("toggleOutline").addEventListener("click", (e) => {
      outlineOnly = !outlineOnly;
      e.target.classList.toggle('active', outlineOnly);
    });

    document.getElementById("toggleGrid").addEventListener("click", (e) => {
      showGrid = !showGrid;
      e.target.classList.toggle('active', showGrid);
    });

    document.getElementById("toggleWarp").addEventListener("click", (e) => {
      warpMode = !warpMode;
      e.target.classList.toggle('active', warpMode);
      // Reset warp state when toggling
      warpStartPoint = null;
      currentStroke = [];
    });

    // Undo button
    document.getElementById("undo").addEventListener("click", () => {
      if (undoStack.length > 0) {
        undoStack.pop(); // remove last stroke
        applyUndoStack(); // redraw canvas
      }
    });

    // ===============================================
    // EXPORT FUNCTIONALITY
    // ===============================================
    
    document.getElementById("send-to-figma").addEventListener("click", () => {
      const exportSize = parseInt(document.getElementById("export-size").value);
      const useLines = document.getElementById("mode-toggle")?.checked ?? false;

      // Calculate bounding box
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      strokes.flat().forEach(p => {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
      });

      const drawingWidth = maxX - minX;
      const drawingHeight = maxY - minY;
      const offsetX = (width - drawingWidth) / 2 - minX;
      const offsetY = (height - drawingHeight) / 2 - minY;

      // Generate SVG
      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${exportSize}" height="${exportSize}" viewBox="0 0 ${width} ${height}">\n`;

      for (let i = 0; i < strokes.length; i++) {
        const strokePath = strokes[i];
        const col = useColors ? strokeColors[i] : color(0);
        const hex = col.toString('#rrggbb');
        const shape = strokeShapes[i] || 'circle';

        if (useLines) {
          // Export as lines
          svg += `<g stroke="${hex}" fill="none" stroke-width="${radius * 2}">\n`;
          for (let j = 0; j < strokePath.length - 1; j++) {
            const a = strokePath[j], b = strokePath[j + 1];
            svg += `<line x1="${a.x + offsetX}" y1="${a.y + offsetY}" x2="${b.x + offsetX}" y2="${b.y + offsetY}" />\n`;
          }
          svg += `</g>\n`;
        } else {
          // Export as filled shapes
          svg += `<g fill="${hex}" stroke="none">\n`;
          for (let j = 0; j < strokePath.length; j++) {
            const p = strokePath[j];
            
            // Draw shape at point
            switch(shape) {
              case 'square':
                svg += `<rect x="${p.x + offsetX - radius}" y="${p.y + offsetY - radius}" width="${radius * 2}" height="${radius * 2}" />\n`;
                break;
              case 'circle':
              default:
                svg += `<circle cx="${p.x + offsetX}" cy="${p.y + offsetY}" r="${radius}" />\n`;
                break;
            }

            // Draw connector
            if (j > 0) {
              const a = strokePath[j - 1], b = p;
              const dx = b.x - a.x;
              const dy = b.y - a.y;
              const len = Math.sqrt(dx * dx + dy * dy);
              const nx = dx / len, ny = dy / len;
              const px = -ny, py = nx;

              let width = radius;
              if (shape === 'square' && squareConnectorMode === 'corner') {
                // For corner mode, we need to export the corner-based connectors
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                
                let aCorner1, aCorner2, bCorner1, bCorner2;
                
                if (abs(dx) > abs(dy)) {
                  // Mostly horizontal
                  if (dx > 0) {
                    aCorner1 = { x: a.x + radius, y: a.y - radius };
                    aCorner2 = { x: a.x + radius, y: a.y + radius };
                    bCorner1 = { x: b.x - radius, y: b.y - radius };
                    bCorner2 = { x: b.x - radius, y: b.y + radius };
                  } else {
                    aCorner1 = { x: a.x - radius, y: a.y - radius };
                    aCorner2 = { x: a.x - radius, y: a.y + radius };
                    bCorner1 = { x: b.x + radius, y: b.y - radius };
                    bCorner2 = { x: b.x + radius, y: b.y + radius };
                  }
                } else {
                  // Mostly vertical
                  if (dy > 0) {
                    aCorner1 = { x: a.x - radius, y: a.y + radius };
                    aCorner2 = { x: a.x + radius, y: a.y + radius };
                    bCorner1 = { x: b.x - radius, y: b.y - radius };
                    bCorner2 = { x: b.x + radius, y: b.y - radius };
                  } else {
                    aCorner1 = { x: a.x - radius, y: a.y - radius };
                    aCorner2 = { x: a.x + radius, y: a.y - radius };
                    bCorner1 = { x: b.x - radius, y: b.y + radius };
                    bCorner2 = { x: b.x + radius, y: b.y + radius };
                  }
                }
                
                // Handle diagonal movements
                if (abs(dx) > 0 && abs(dy) > 0 && abs(abs(dx) - abs(dy)) < 10) {
                  if (dx > 0 && dy > 0) {
                    aCorner1 = { x: a.x + radius, y: a.y - radius };
                    aCorner2 = { x: a.x - radius, y: a.y + radius };
                    bCorner1 = { x: b.x + radius, y: b.y - radius };
                    bCorner2 = { x: b.x - radius, y: b.y + radius };
                  } else if (dx > 0 && dy < 0) {
                    aCorner1 = { x: a.x - radius, y: a.y - radius };
                    aCorner2 = { x: a.x + radius, y: a.y + radius };
                    bCorner1 = { x: b.x - radius, y: b.y - radius };
                    bCorner2 = { x: b.x + radius, y: b.y + radius };
                  } else if (dx < 0 && dy > 0) {
                    aCorner1 = { x: a.x + radius, y: a.y + radius };
                    aCorner2 = { x: a.x - radius, y: a.y - radius };
                    bCorner1 = { x: b.x + radius, y: b.y + radius };
                    bCorner2 = { x: b.x - radius, y: b.y - radius };
                  } else {
                    aCorner1 = { x: a.x - radius, y: a.y + radius };
                    aCorner2 = { x: a.x + radius, y: a.y - radius };
                    bCorner1 = { x: b.x - radius, y: b.y + radius };
                    bCorner2 = { x: b.x + radius, y: b.y - radius };
                  }
                }
                
                svg += `<path d="M ${aCorner1.x + offsetX} ${aCorner1.y + offsetY} L ${bCorner1.x + offsetX} ${bCorner1.y + offsetY} L ${bCorner2.x + offsetX} ${bCorner2.y + offsetY} L ${aCorner2.x + offsetX} ${aCorner2.y + offsetY} Z" fill="${hex}" />\n`;
              } else {
                // Center mode for squares or circles
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / len, ny = dy / len;
                const px = -ny, py = nx;

                const ax1 = a.x + px * width + offsetX;
                const ay1 = a.y + py * width + offsetY;
                const ax2 = a.x - px * width + offsetX;
                const ay2 = a.y - py * width + offsetY;
                const bx1 = b.x + px * width + offsetX;
                const by1 = b.y + py * width + offsetY;
                const bx2 = b.x - px * width + offsetX;
                const by2 = b.y - py * width + offsetY;

                svg += `<path d="M ${ax1} ${ay1} L ${bx1} ${by1} L ${bx2} ${by2} L ${ax2} ${ay2} Z" fill="${hex}" />\n`;
              }
            }
          }
          svg += `</g>\n`;
        }
      }

      svg += `</svg>`;
      parent.postMessage({ pluginMessage: { type: 'svg', data: svg, stayOpen: true } }, '*');
    });

    // ===============================================
    // SURPRISE ME FUNCTION
    // ===============================================
    
    document.getElementById("surprise").addEventListener("click", () => {
      strokes = [];
      strokeColors = [];
      strokeShapes = [];
      undoStack = [];

      const totalStrokes = floor(random(3, 8));

      for (let s = 0; s < totalStrokes; s++) {
        let stroke = [];
        let visited = new Set();
        let x = floor(random(cols));
        let y = floor(random(rows));
        let length = floor(random(4, 10));

        for (let i = 0; i < length; i++) {
          if (x < 0 || x >= cols || y < 0 || y >= rows) break;
          let key = `${x},${y}`;
          if (visited.has(key)) break;

          stroke.push(grid[x][y].copy());
          visited.add(key);

          const directions = [
            [1, 0], [-1, 0],
            [0, 1], [0, -1],
            [1, 1], [-1, -1],
            [-1, 1], [1, -1]
          ];

          let [dx, dy] = random(directions);
          x += dx;
          y += dy;
        }

        if (stroke.length > 1) {
          const col = useColors
            ? color(random(30, 255), random(30, 255), random(30, 255))
            : color(0);
          undoStack.push({ stroke: stroke.map(p => p.copy()), color: col, shape: brushShape });
        }
      }

      applyUndoStack();
    });

    // Game of Life button
    document.getElementById("toggleGameOfLife").addEventListener("click", (e) => {
      gameOfLifeMode = !gameOfLifeMode;
      e.target.classList.toggle('active', gameOfLifeMode);
      
      const golControls = document.getElementById('game-of-life-controls');
      if (gameOfLifeMode) {
        golControls.style.display = 'block';
        initGameOfLife();
        // Disable other drawing modes
        warpMode = false;
        document.getElementById('toggleWarp').classList.remove('active');
      } else {
        golControls.style.display = 'none';
        gameOfLifeRunning = false;
        document.getElementById('gol-play').textContent = 'PLAY';
        document.getElementById('gol-play').style.background = '#4CAF50';
      }
    });
    
    // Game of Life controls
    document.getElementById('gol-play').addEventListener('click', (e) => {
      gameOfLifeRunning = !gameOfLifeRunning;
      if (gameOfLifeRunning) {
        e.target.textContent = 'PAUSE';
        e.target.style.background = '#f44336';
      } else {
        e.target.textContent = 'PLAY';
        e.target.style.background = '#4CAF50';
      }
    });
    
    document.getElementById('gol-step').addEventListener('click', () => {
      updateGameOfLife();
    });
    
    document.getElementById('gol-clear').addEventListener('click', () => {
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          gameOfLifeGrid[i][j] = false;
        }
      }
      gameOfLifeRunning = false;
      document.getElementById('gol-play').textContent = 'PLAY';
      document.getElementById('gol-play').style.background = '#4CAF50';
    });
    
    // Game of Life speed control
    document.getElementById('gol-speed').addEventListener('input', (e) => {
      gameOfLifeSpeed = parseInt(e.target.value);
      document.getElementById('gol-speed-val').textContent = e.target.value;
    });

    // ===============================================
    // KEYBOARD SHORTCUTS
    // ===============================================
    
    document.addEventListener('keydown', (e) => {
      switch(e.key.toLowerCase()) {
        case 'g': document.getElementById('toggleGrid').click(); break;
        case 'c': document.getElementById('toggleColor').click(); break;
        case 'o': document.getElementById('toggleOutline').click(); break;
        case 'w': document.getElementById('toggleWarp').click(); break;
        case 'f': document.getElementById('send-to-figma').click(); break;
        case 's': document.getElementById('surprise').click(); break;
        case 'x': document.getElementById('clear').click(); break;
        case 'z': document.getElementById('undo').click(); break;
        case 'l': document.getElementById('toggleGameOfLife').click(); break;
        // Add number shortcuts for shapes
        case '1': document.querySelector('[data-shape="circle"]').click(); break;
        case '2': document.querySelector('[data-shape="square"]').click(); break;
      }
    });
  </script>
</body>
</html>